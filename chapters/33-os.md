# Chapter 33: os 包 - 操作系統交互

## 概述

`os` 包提供了與操作系統交互的功能，包括環境變量、命令行參數、進程管理等。對於 Node.js 開發者來說，它相當於 `process` 對象和部分 `child_process` 模塊的功能。

## Node.js 與 Go 的對比

| 功能 | Node.js | Go |
|------|---------|-----|
| 環境變量（讀取） | `process.env.KEY` | `os.Getenv("KEY")` |
| 環境變量（設置） | `process.env.KEY = value` | `os.Setenv("KEY", value)` |
| 所有環境變量 | `process.env` | `os.Environ()` |
| 命令行參數 | `process.argv` | `os.Args` |
| 退出程序 | `process.exit(code)` | `os.Exit(code)` |
| 當前目錄 | `process.cwd()` | `os.Getwd()` |
| 改變目錄 | `process.chdir(dir)` | `os.Chdir(dir)` |
| 主機名 | `os.hostname()` | `os.Hostname()` |
| 用戶信息 | `os.userInfo()` | `user.Current()` |
| 執行命令 | `child_process.exec()` | `os/exec.Command()` |
| 標準輸入 | `process.stdin` | `os.Stdin` |
| 標準輸出 | `process.stdout` | `os.Stdout` |
| 標準錯誤 | `process.stderr` | `os.Stderr` |

## 詳細概念解釋

### 1. 環境變量

環境變量用於配置應用程序行為：
- `os.Getenv(key)` - 獲取環境變量
- `os.Setenv(key, value)` - 設置環境變量
- `os.Unsetenv(key)` - 刪除環境變量
- `os.Environ()` - 獲取所有環境變量
- `os.LookupEnv(key)` - 查找環境變量（區分空值和不存在）

### 2. 命令行參數

- `os.Args` - 字符串切片，包含所有命令行參數
- `os.Args[0]` - 程序名稱
- `os.Args[1:]` - 實際參數

### 3. 進程信息

- `os.Getpid()` - 獲取進程 ID
- `os.Getppid()` - 獲取父進程 ID
- `os.Getuid()` - 獲取用戶 ID（Unix）
- `os.Getgid()` - 獲取組 ID（Unix）

### 4. 標準流

- `os.Stdin` - 標準輸入 (io.Reader)
- `os.Stdout` - 標準輸出 (io.Writer)
- `os.Stderr` - 標準錯誤 (io.Writer)

## 實際代碼示例

### 示例 1: 環境變量

**Go:**
```go
package main

import (
    "fmt"
    "os"
    "strings"
)

func main() {
    // 讀取環境變量
    home := os.Getenv("HOME")
    fmt.Println("HOME:", home)

    path := os.Getenv("PATH")
    fmt.Println("PATH:", path)

    // 讀取不存在的環境變量
    custom := os.Getenv("CUSTOM_VAR")
    fmt.Println("CUSTOM_VAR:", custom) // 返回空字符串

    // LookupEnv - 區分空值和不存在
    value, exists := os.LookupEnv("CUSTOM_VAR")
    if exists {
        fmt.Printf("CUSTOM_VAR exists: '%s'\n", value)
    } else {
        fmt.Println("CUSTOM_VAR does not exist")
    }

    // 設置環境變量
    os.Setenv("MY_APP_ENV", "development")
    os.Setenv("MY_APP_PORT", "8080")

    fmt.Println("MY_APP_ENV:", os.Getenv("MY_APP_ENV"))
    fmt.Println("MY_APP_PORT:", os.Getenv("MY_APP_PORT"))

    // 獲取所有環境變量
    fmt.Println("\nAll environment variables:")
    for _, env := range os.Environ() {
        // 格式: KEY=VALUE
        pair := strings.SplitN(env, "=", 2)
        if strings.HasPrefix(pair[0], "MY_APP_") {
            fmt.Printf("%s = %s\n", pair[0], pair[1])
        }
    }

    // 刪除環境變量
    os.Unsetenv("MY_APP_ENV")
    fmt.Println("\nAfter unset MY_APP_ENV:", os.Getenv("MY_APP_ENV"))
}
```

**Node.js:**
```javascript
// 讀取環境變量
const home = process.env.HOME;
console.log("HOME:", home);

const path = process.env.PATH;
console.log("PATH:", path);

// 讀取不存在的環境變量
const custom = process.env.CUSTOM_VAR;
console.log("CUSTOM_VAR:", custom); // 返回 undefined

// 檢查環境變量是否存在
if ('CUSTOM_VAR' in process.env) {
    console.log(`CUSTOM_VAR exists: '${process.env.CUSTOM_VAR}'`);
} else {
    console.log("CUSTOM_VAR does not exist");
}

// 設置環境變量
process.env.MY_APP_ENV = "development";
process.env.MY_APP_PORT = "8080";

console.log("MY_APP_ENV:", process.env.MY_APP_ENV);
console.log("MY_APP_PORT:", process.env.MY_APP_PORT);

// 獲取所有環境變量
console.log("\nAll environment variables:");
Object.keys(process.env)
    .filter(key => key.startsWith('MY_APP_'))
    .forEach(key => {
        console.log(`${key} = ${process.env[key]}`);
    });

// 刪除環境變量
delete process.env.MY_APP_ENV;
console.log("\nAfter delete MY_APP_ENV:", process.env.MY_APP_ENV);
```

### 示例 2: 命令行參數

**Go:**
```go
package main

import (
    "fmt"
    "os"
    "strconv"
)

func main() {
    // 顯示所有參數
    fmt.Println("Program name:", os.Args[0])
    fmt.Println("Number of arguments:", len(os.Args)-1)

    if len(os.Args) > 1 {
        fmt.Println("\nArguments:")
        for i, arg := range os.Args[1:] {
            fmt.Printf("  [%d]: %s\n", i, arg)
        }
    }

    // 解析參數示例
    if len(os.Args) < 3 {
        fmt.Println("\nUsage: program <name> <age>")
        os.Exit(1)
    }

    name := os.Args[1]
    age, err := strconv.Atoi(os.Args[2])
    if err != nil {
        fmt.Println("Error: age must be a number")
        os.Exit(1)
    }

    fmt.Printf("\nHello %s, you are %d years old\n", name, age)

    // 使用 flag 包解析參數（更好的方式）
    // import "flag"
    // name := flag.String("name", "Guest", "Your name")
    // age := flag.Int("age", 0, "Your age")
    // flag.Parse()
}

// 運行: go run program.go Alice 30
```

**Node.js:**
```javascript
// 顯示所有參數
console.log("Program name:", process.argv[0]); // node
console.log("Script name:", process.argv[1]);  // script path
console.log("Number of arguments:", process.argv.length - 2);

if (process.argv.length > 2) {
    console.log("\nArguments:");
    process.argv.slice(2).forEach((arg, i) => {
        console.log(`  [${i}]: ${arg}`);
    });
}

// 解析參數示例
if (process.argv.length < 4) {
    console.log("\nUsage: node program.js <name> <age>");
    process.exit(1);
}

const name = process.argv[2];
const age = parseInt(process.argv[3], 10);

if (isNaN(age)) {
    console.log("Error: age must be a number");
    process.exit(1);
}

console.log(`\nHello ${name}, you are ${age} years old`);

// 使用庫解析參數（更好的方式）
// const yargs = require('yargs');
// const argv = yargs.option('name', {...}).option('age', {...}).argv;

// 運行: node program.js Alice 30
```

### 示例 3: 進程信息

**Go:**
```go
package main

import (
    "fmt"
    "os"
    "runtime"
)

func main() {
    // 進程 ID
    fmt.Println("Process ID:", os.Getpid())
    fmt.Println("Parent Process ID:", os.Getppid())

    // 主機名
    hostname, _ := os.Hostname()
    fmt.Println("Hostname:", hostname)

    // 當前工作目錄
    cwd, _ := os.Getwd()
    fmt.Println("Current directory:", cwd)

    // 可執行文件路徑
    executable, _ := os.Executable()
    fmt.Println("Executable:", executable)

    // 臨時目錄
    fmt.Println("Temp directory:", os.TempDir())

    // 系統信息
    fmt.Println("\nSystem information:")
    fmt.Println("OS:", runtime.GOOS)
    fmt.Println("Architecture:", runtime.GOARCH)
    fmt.Println("CPUs:", runtime.NumCPU())
    fmt.Println("Go version:", runtime.Version())

    // 用戶信息（Unix only）
    if runtime.GOOS != "windows" {
        fmt.Println("\nUser information:")
        fmt.Println("UID:", os.Getuid())
        fmt.Println("GID:", os.Getgid())
    }
}
```

**Node.js:**
```javascript
const os = require('os');
const path = require('path');

// 進程 ID
console.log("Process ID:", process.pid);
console.log("Parent Process ID:", process.ppid);

// 主機名
console.log("Hostname:", os.hostname());

// 當前工作目錄
console.log("Current directory:", process.cwd());

// 可執行文件路徑
console.log("Executable:", process.execPath);

// 臨時目錄
console.log("Temp directory:", os.tmpdir());

// 系統信息
console.log("\nSystem information:");
console.log("OS:", process.platform);
console.log("Architecture:", process.arch);
console.log("CPUs:", os.cpus().length);
console.log("Node version:", process.version);

// 用戶信息
if (process.platform !== 'win32') {
    console.log("\nUser information:");
    console.log("UID:", process.getuid());
    console.log("GID:", process.getgid());
}
```

### 示例 4: 標準輸入輸出

**Go:**
```go
package main

import (
    "bufio"
    "fmt"
    "os"
    "strings"
)

func main() {
    // 標準輸出
    fmt.Fprintln(os.Stdout, "This is stdout")
    fmt.Fprintln(os.Stderr, "This is stderr")

    // 讀取標準輸入
    reader := bufio.NewReader(os.Stdin)
    fmt.Print("Enter your name: ")

    name, _ := reader.ReadString('\n')
    name = strings.TrimSpace(name)

    fmt.Fprintf(os.Stdout, "Hello, %s!\n", name)

    // 交互式輸入示例
    for {
        fmt.Print("Enter command (type 'quit' to exit): ")
        input, _ := reader.ReadString('\n')
        input = strings.TrimSpace(input)

        if input == "quit" {
            fmt.Println("Goodbye!")
            break
        }

        fmt.Printf("You entered: %s\n", input)
    }
}
```

**Node.js:**
```javascript
const readline = require('readline');

// 標準輸出
process.stdout.write("This is stdout\n");
process.stderr.write("This is stderr\n");

// 讀取標準輸入
const rl = readline.createInterface({
    input: process.stdin,
    output: process.stdout
});

rl.question('Enter your name: ', (name) => {
    process.stdout.write(`Hello, ${name}!\n`);

    // 交互式輸入示例
    const askCommand = () => {
        rl.question("Enter command (type 'quit' to exit): ", (input) => {
            input = input.trim();

            if (input === 'quit') {
                console.log("Goodbye!");
                rl.close();
                return;
            }

            console.log(`You entered: ${input}`);
            askCommand();
        });
    };

    askCommand();
});
```

### 示例 5: 執行外部命令

**Go:**
```go
package main

import (
    "fmt"
    "os/exec"
    "strings"
)

func main() {
    // 執行簡單命令
    cmd := exec.Command("echo", "Hello from Go")
    output, err := cmd.Output()
    if err != nil {
        fmt.Println("Error:", err)
        return
    }
    fmt.Println("Output:", string(output))

    // 執行命令並獲取標準輸出和標準錯誤
    cmd = exec.Command("ls", "-la")
    combinedOutput, err := cmd.CombinedOutput()
    if err != nil {
        fmt.Println("Error:", err)
    }
    fmt.Println("Combined output:")
    fmt.Println(string(combinedOutput))

    // 使用管道
    cmd = exec.Command("ps", "aux")
    grep := exec.Command("grep", "go")

    grep.Stdin, _ = cmd.StdoutPipe()
    grep.Stdout = &strings.Builder{}

    _ = grep.Start()
    _ = cmd.Run()
    _ = grep.Wait()

    fmt.Println("Piped output:", grep.Stdout)

    // 設置環境變量和工作目錄
    cmd = exec.Command("pwd")
    cmd.Dir = "/tmp"
    cmd.Env = append(cmd.Environ(), "CUSTOM_VAR=value")
    output, _ = cmd.Output()
    fmt.Println("Working directory:", string(output))
}
```

**Node.js:**
```javascript
const { exec, execSync, spawn } = require('child_process');
const { promisify } = require('util');
const execAsync = promisify(exec);

async function main() {
    // 執行簡單命令（同步）
    try {
        const output = execSync('echo "Hello from Node.js"', { encoding: 'utf8' });
        console.log("Output:", output.trim());
    } catch (err) {
        console.error("Error:", err.message);
    }

    // 執行命令（異步）
    try {
        const { stdout, stderr } = await execAsync('ls -la');
        console.log("Combined output:");
        console.log(stdout);
        if (stderr) console.error(stderr);
    } catch (err) {
        console.error("Error:", err.message);
    }

    // 使用 spawn（流式）
    const ps = spawn('ps', ['aux']);
    const grep = spawn('grep', ['node']);

    ps.stdout.pipe(grep.stdin);

    grep.stdout.on('data', (data) => {
        console.log("Piped output:", data.toString());
    });

    grep.on('close', (code) => {
        console.log(`Grep process exited with code ${code}`);
    });

    // 設置環境變量和工作目錄
    const pwd = spawn('pwd', [], {
        cwd: '/tmp',
        env: { ...process.env, CUSTOM_VAR: 'value' }
    });

    pwd.stdout.on('data', (data) => {
        console.log("Working directory:", data.toString().trim());
    });
}

main();
```

### 示例 6: 信號處理

**Go:**
```go
package main

import (
    "fmt"
    "os"
    "os/signal"
    "syscall"
    "time"
)

func main() {
    // 創建信號通道
    sigChan := make(chan os.Signal, 1)

    // 註冊要接收的信號
    signal.Notify(sigChan, syscall.SIGINT, syscall.SIGTERM)

    // 後台任務
    go func() {
        ticker := time.NewTicker(1 * time.Second)
        defer ticker.Stop()

        for {
            select {
            case <-ticker.C:
                fmt.Println("Working...")
            }
        }
    }()

    // 等待信號
    fmt.Println("Server started. Press Ctrl+C to stop.")
    sig := <-sigChan

    fmt.Printf("\nReceived signal: %v\n", sig)
    fmt.Println("Cleaning up...")
    time.Sleep(1 * time.Second)
    fmt.Println("Shutdown complete.")
}
```

**Node.js:**
```javascript
// 註冊信號處理器
process.on('SIGINT', () => {
    console.log('\nReceived signal: SIGINT');
    cleanup();
});

process.on('SIGTERM', () => {
    console.log('\nReceived signal: SIGTERM');
    cleanup();
});

function cleanup() {
    console.log('Cleaning up...');
    setTimeout(() => {
        console.log('Shutdown complete.');
        process.exit(0);
    }, 1000);
}

// 後台任務
const interval = setInterval(() => {
    console.log('Working...');
}, 1000);

console.log('Server started. Press Ctrl+C to stop.');

// 確保程序不會立即退出
process.stdin.resume();
```

### 示例 7: 退出碼和錯誤處理

**Go:**
```go
package main

import (
    "errors"
    "fmt"
    "os"
)

func doWork() error {
    // 模擬工作
    success := false

    if !success {
        return errors.New("work failed")
    }

    return nil
}

func main() {
    // 方法 1: 直接退出
    if len(os.Args) < 2 {
        fmt.Fprintln(os.Stderr, "Error: missing argument")
        os.Exit(1)
    }

    // 方法 2: 通過返回值處理錯誤
    if err := run(); err != nil {
        fmt.Fprintf(os.Stderr, "Error: %v\n", err)
        os.Exit(1)
    }
}

func run() error {
    err := doWork()
    if err != nil {
        return fmt.Errorf("run failed: %w", err)
    }

    fmt.Println("Success!")
    return nil
}
```

**Node.js:**
```javascript
function doWork() {
    // 模擬工作
    const success = false;

    if (!success) {
        throw new Error('work failed');
    }
}

function run() {
    try {
        doWork();
        console.log('Success!');
    } catch (err) {
        throw new Error(`run failed: ${err.message}`);
    }
}

// 方法 1: 直接退出
if (process.argv.length < 3) {
    console.error('Error: missing argument');
    process.exit(1);
}

// 方法 2: 通過 try-catch 處理錯誤
try {
    run();
} catch (err) {
    console.error(`Error: ${err.message}`);
    process.exit(1);
}

// 捕獲未處理的異常
process.on('uncaughtException', (err) => {
    console.error('Uncaught Exception:', err);
    process.exit(1);
});

// 捕獲未處理的 Promise rejection
process.on('unhandledRejection', (reason, promise) => {
    console.error('Unhandled Rejection at:', promise, 'reason:', reason);
    process.exit(1);
});
```

### 示例 8: 配置管理

**Go:**
```go
package main

import (
    "fmt"
    "os"
    "strconv"
)

type Config struct {
    Host     string
    Port     int
    Debug    bool
    Database string
}

func LoadConfig() *Config {
    config := &Config{
        Host:     getEnv("APP_HOST", "localhost"),
        Port:     getEnvInt("APP_PORT", 8080),
        Debug:    getEnvBool("APP_DEBUG", false),
        Database: getEnv("DATABASE_URL", "postgres://localhost/mydb"),
    }

    return config
}

func getEnv(key, defaultValue string) string {
    if value := os.Getenv(key); value != "" {
        return value
    }
    return defaultValue
}

func getEnvInt(key string, defaultValue int) int {
    if value := os.Getenv(key); value != "" {
        if intValue, err := strconv.Atoi(value); err == nil {
            return intValue
        }
    }
    return defaultValue
}

func getEnvBool(key string, defaultValue bool) bool {
    if value := os.Getenv(key); value != "" {
        if boolValue, err := strconv.ParseBool(value); err == nil {
            return boolValue
        }
    }
    return defaultValue
}

func main() {
    // 設置環境變量（測試用）
    os.Setenv("APP_HOST", "0.0.0.0")
    os.Setenv("APP_PORT", "3000")
    os.Setenv("APP_DEBUG", "true")

    config := LoadConfig()

    fmt.Printf("Configuration:\n")
    fmt.Printf("  Host: %s\n", config.Host)
    fmt.Printf("  Port: %d\n", config.Port)
    fmt.Printf("  Debug: %t\n", config.Debug)
    fmt.Printf("  Database: %s\n", config.Database)
}
```

**Node.js:**
```javascript
class Config {
    constructor() {
        this.host = this.getEnv('APP_HOST', 'localhost');
        this.port = this.getEnvInt('APP_PORT', 8080);
        this.debug = this.getEnvBool('APP_DEBUG', false);
        this.database = this.getEnv('DATABASE_URL', 'postgres://localhost/mydb');
    }

    getEnv(key, defaultValue) {
        return process.env[key] || defaultValue;
    }

    getEnvInt(key, defaultValue) {
        const value = process.env[key];
        if (value !== undefined) {
            const intValue = parseInt(value, 10);
            if (!isNaN(intValue)) {
                return intValue;
            }
        }
        return defaultValue;
    }

    getEnvBool(key, defaultValue) {
        const value = process.env[key];
        if (value !== undefined) {
            return value === 'true' || value === '1';
        }
        return defaultValue;
    }
}

// 設置環境變量（測試用）
process.env.APP_HOST = '0.0.0.0';
process.env.APP_PORT = '3000';
process.env.APP_DEBUG = 'true';

const config = new Config();

console.log('Configuration:');
console.log(`  Host: ${config.host}`);
console.log(`  Port: ${config.port}`);
console.log(`  Debug: ${config.debug}`);
console.log(`  Database: ${config.database}`);

// 或使用 dotenv 庫
// require('dotenv').config();
```

## 重點總結

1. **環境變量**
   - `os.Getenv()` - 讀取環境變量
   - `os.Setenv()` - 設置環境變量
   - `os.LookupEnv()` - 檢查環境變量是否存在
   - 用於配置管理

2. **命令行參數**
   - `os.Args` - 獲取所有參數
   - 使用 `flag` 包解析更複雜的參數
   - 第一個參數是程序名稱

3. **進程管理**
   - `os.Getpid()` - 進程 ID
   - `os.Exit()` - 退出程序
   - `signal` 包處理系統信號

4. **執行命令**
   - `os/exec` 包執行外部命令
   - `exec.Command()` 創建命令
   - 可設置環境變量和工作目錄

5. **標準流**
   - `os.Stdin`, `os.Stdout`, `os.Stderr`
   - 實現 `io.Reader` 和 `io.Writer` 接口

6. **與 Node.js 的主要差異**
   - Go 的環境變量需要函數調用，Node.js 直接訪問對象
   - Go 的命令行參數是切片，Node.js 是數組
   - Go 使用 channel 處理信號，Node.js 使用事件
   - Go 的錯誤處理更明確

7. **最佳實踐**
   - 使用環境變量配置應用
   - 正確處理信號，優雅關閉
   - 總是檢查錯誤
   - 使用適當的退出碼
   - 使用 flag 包解析參數

## 練習題

### 練習 1: 環境配置
創建環境配置管理器，支持多環境（development, staging, production）。

### 練習 2: CLI 工具
實現簡單的 CLI 工具，支持子命令和標誌。

### 練習 3: 進程監控
編寫程序定期檢查另一個進程是否運行。

### 練習 4: 日誌工具
實現日誌工具，根據環境變量設置日誌級別。

### 練習 5: 腳本執行器
創建腳本執行器，支持超時和重試。

### 練習 6: 系統信息收集器
編寫程序收集系統信息並以 JSON 格式輸出。

### 練習 7: 優雅關閉
實現支持優雅關閉的 HTTP 服務器。

### 練習 8: 管道處理
創建程序從標準輸入讀取數據，處理後輸出到標準輸出（類似 Unix 管道）。

## 參考答案

### 練習 1 答案
```go
package main

import (
    "fmt"
    "os"
)

type Environment string

const (
    Development Environment = "development"
    Staging     Environment = "staging"
    Production  Environment = "production"
)

type Config struct {
    Env      Environment
    Host     string
    Port     int
    Debug    bool
    LogLevel string
}

func LoadConfig() *Config {
    env := Environment(getEnv("APP_ENV", "development"))

    config := &Config{
        Env: env,
    }

    switch env {
    case Development:
        config.Host = "localhost"
        config.Port = 8080
        config.Debug = true
        config.LogLevel = "debug"
    case Staging:
        config.Host = "0.0.0.0"
        config.Port = 8080
        config.Debug = true
        config.LogLevel = "info"
    case Production:
        config.Host = "0.0.0.0"
        config.Port = 80
        config.Debug = false
        config.LogLevel = "warn"
    default:
        fmt.Fprintf(os.Stderr, "Unknown environment: %s\n", env)
        os.Exit(1)
    }

    // 環境變量覆蓋默認值
    if host := os.Getenv("APP_HOST"); host != "" {
        config.Host = host
    }

    return config
}

func getEnv(key, defaultValue string) string {
    if value := os.Getenv(key); value != "" {
        return value
    }
    return defaultValue
}

func main() {
    // 測試不同環境
    environments := []string{"development", "staging", "production"}

    for _, env := range environments {
        os.Setenv("APP_ENV", env)
        config := LoadConfig()

        fmt.Printf("\nEnvironment: %s\n", config.Env)
        fmt.Printf("Host: %s\n", config.Host)
        fmt.Printf("Port: %d\n", config.Port)
        fmt.Printf("Debug: %t\n", config.Debug)
        fmt.Printf("LogLevel: %s\n", config.LogLevel)
    }
}
```

### 練習 7 答案
```go
package main

import (
    "context"
    "fmt"
    "net/http"
    "os"
    "os/signal"
    "syscall"
    "time"
)

func main() {
    // 創建 HTTP 服務器
    mux := http.NewServeMux()
    mux.HandleFunc("/", func(w http.ResponseWriter, r *http.Request) {
        time.Sleep(2 * time.Second) // 模擬長時間處理
        fmt.Fprintf(w, "Hello, World!\n")
    })

    server := &http.Server{
        Addr:    ":8080",
        Handler: mux,
    }

    // 啟動服務器
    go func() {
        fmt.Println("Server starting on :8080")
        if err := server.ListenAndServe(); err != nil && err != http.ErrServerClosed {
            fmt.Fprintf(os.Stderr, "Server error: %v\n", err)
            os.Exit(1)
        }
    }()

    // 等待中斷信號
    sigChan := make(chan os.Signal, 1)
    signal.Notify(sigChan, syscall.SIGINT, syscall.SIGTERM)

    <-sigChan
    fmt.Println("\nShutdown signal received")

    // 優雅關閉
    ctx, cancel := context.WithTimeout(context.Background(), 30*time.Second)
    defer cancel()

    fmt.Println("Shutting down server...")
    if err := server.Shutdown(ctx); err != nil {
        fmt.Fprintf(os.Stderr, "Server shutdown error: %v\n", err)
        os.Exit(1)
    }

    fmt.Println("Server stopped gracefully")
}
```
